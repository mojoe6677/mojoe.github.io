<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projektbeschreibung: Implementierung eines Failover-Systems mit OPNSense</title>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            background: black; /* Fallback background color */
            color: white;
            flex-direction: column;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 2;
            max-width: 800px;
            margin: 20px;
            background: rgba(0, 0, 0, 0.8); /* Semi-transparent background */
            padding: 20px;
            border-radius: 10px;
        }

        h1, h2, h3 {
            color: #34d399; /* Emerald green */
        }

        ul {
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>
    <div class="content">
        <h1>Projektbeschreibung: Implementierung eines Failover-Systems mit OPNSense</h1>
        <h2>Projektübersicht:</h2>
        <p>Im Rahmen dieses Projekts wurde ein robustes und zuverlässiges Failover-System erstellt, das auf zwei identischen Barebone-Servern basiert. Auf beiden Servern wurde OPNSense installiert, um eine hohe Verfügbarkeit und Ausfallsicherheit zu gewährleisten. Zusätzlich wurde das System für lokale DNS-Resolving-Aufgaben mit Unbound DNS konfiguriert und der Netzwerkschutz durch die Implementierung von Suricata erhöht.</p>
        
        <h2>Projektziele:</h2>
        <ul>
            <li>Erstellung eines Failover-Systems mit hoher Verfügbarkeit.</li>
            <li>Sicherstellung der kontinuierlichen Netzwerkfunktionalität durch redundante Server.</li>
            <li>Implementierung eines lokalen DNS-Resolvers.</li>
            <li>Verbesserung der Netzwerksicherheit durch Intrusion Detection und Prevention.</li>
        </ul>
        
        <h2>Systemkomponenten:</h2>
        <h3>Hardware:</h3>
        <ul>
            <li>Zwei identische Barebone-Server als Basis für das Failover-System.</li>
        </ul>
        <h3>Software:</h3>
        <ul>
            <li><strong>OPNSense:</strong> Open-Source-Firewall-Lösung zur Verwaltung und Sicherung des Netzwerks.</li>
            <li><strong>Unbound DNS:</strong> Lokaler DNS-Resolver zur Verbesserung der DNS-Auflösungsgeschwindigkeit und Reduzierung der Abhängigkeit von externen DNS-Diensten.</li>
            <li><strong>Suricata:</strong> Intrusion Detection and Prevention System (IDPS) zur Überwachung des Netzwerkverkehrs und zum Schutz vor Bedrohungen.</li>
        </ul>
        
        <h2>Implementierungsschritte:</h2>
        <h3>Installation von OPNSense:</h3>
        <ul>
            <li>Installation und Grundkonfiguration von OPNSense auf beiden Barebone-Servern.</li>
            <li>Konfiguration von High Availability (HA) Funktionen, um ein Failover zwischen den beiden Servern zu ermöglichen.</li>
        </ul>
        <h3>Konfiguration von Unbound DNS:</h3>
        <ul>
            <li>Einrichtung von Unbound DNS auf beiden OPNSense-Instanzen zur Bereitstellung lokaler DNS-Resolving-Dienste.</li>
            <li>Sicherstellung der Synchronisation und Konsistenz der DNS-Daten zwischen den beiden Servern.</li>
        </ul>
        <h3>Einrichtung von Suricata:</h3>
        <ul>
            <li>Installation und Konfiguration von Suricata auf beiden OPNSense-Instanzen.</li>
            <li>Definition von Regeln und Policies zur Überwachung und Sicherung des Netzwerkverkehrs.</li>
        </ul>
        
        <h3>Test und Validierung:</h3>
        <ul>
            <li>Durchführung umfangreicher Tests, um die Failover-Funktionalität und die Performance des DNS-Resolvers zu überprüfen.</li>
            <li>Simulation von Netzwerkausfällen und Angriffsszenarien zur Validierung der Wirksamkeit von Suricata.</li>
        </ul>
        
        <h2>Ergebnisse:</h2>
        <p>Durch die Implementierung dieses Projekts wurde ein hochverfügbares und sicheres Netzwerkumfeld geschaffen, das den kontinuierlichen Betrieb auch bei Hardwareausfällen gewährleistet. Die lokale DNS-Auflösung mit Unbound DNS hat die Netzwerkperformance verbessert, während Suricata als zusätzliche Schutzschicht gegen Bedrohungen im Netzwerk fungiert.</p>
        
        <h2>Zusammenfassung:</h2>
        <p>Dieses Projekt demonstriert die erfolgreiche Umsetzung eines Failover-Systems mit OPNSense auf zwei Barebone-Servern, die durch Unbound DNS und Suricata ergänzt wurden. Die Konfiguration und Implementierung dieser Komponenten haben zu einem resilienten und sicheren Netzwerk geführt, das sowohl die Ausfallsicherheit als auch die Sicherheitsanforderungen erfüllt.</p>
    </div>
    <script>
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const letters = '0123456789ABCDEF'.split('');
        const fontSize = 16;
        const columns = canvas.width / fontSize;

        const drops = [];
        for (let x = 0; x < columns; x++) {
            drops[x] = 1;
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#0F0';
            ctx.font = `${fontSize}px arial`;

            for (let i = 0; i < drops.length; i++) {
                const text = letters[Math.floor(Math.random() * letters.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }
        }

        setInterval(draw, 33);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
